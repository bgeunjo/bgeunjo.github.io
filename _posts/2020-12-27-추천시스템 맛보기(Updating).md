---

layout: post
title:  "추천 시스템 맛보기(Updating)"
date:   2020-12-27
categories: ["2020","AI"]
update: 2020-12-27
tags: [AI,Recommendation]
---



저 번에 쓴 **Preliminary of Recommendation**에서 추천 시스템에 대한 개요와 협업 필터링 방식에 대해 간단히 설명했었습니다. 이 번에는 추천 시스템을 입문하기 위해 데이터셋을 불러오고 그 데이터셋에 대해 테스트해볼까 합니다. 

이 글은 fast campus 이재원 강사님의 '딥러닝을 활용한 추천시스템 구현 올인원 패키지 Online'의 내용 중 일부입니다.

### 데이터셋 불러오기

Movielens 데이터셋을 사용할 건데 **MovieLens Latest Datasets** 중 Small 데이터 셋을 사용하겠습니다.

[이 링크](https://grouplens.org/datasets/movielens/)에 가시면 다운로드하실 수 있습니다.

다운로드 받으시면 여러 csv파일이 있는데 그 중 주로 보게 되는 파일이 `ratings.csv`입니다. 추천 시스템에서 풀고자 하는 문제는 사용자가 아이템에 대해 어떤 rating을 남길 지 예측하는 것이기 때문입니다.  `pandas`모듈의 `read_csv()`를 통해 csv 파일을 DataFrame으로 읽어오면 됩니다.

``` python
import pandas as pd
ratings_df = pd.read_csv(os.path.join(path, 'ratings.csv'), encoding='utf-8')
movies_df = pd.read_csv(os.path.join(path, 'movies.csv'), index_col='movieId', encoding='utf-8')
tags_df = pd.read_csv(os.path.join(path, 'tags.csv'), encoding='utf-8')
```

`ratings_df`의 내용을 보면 `userId`, `movieId`, `rating`이 주 컨텐츠입니다.

![image](https://user-images.githubusercontent.com/51329156/103155936-470d3f00-47e7-11eb-971a-d40df6d24907.png)

### 데이터셋을 학습셋과 평가셋으로 나누기

`sklearn`에서 데이터셋을 학습셋과 평가셋으로 나누는 기능을 지원합니다.

``` python
from sklearn.model_selection import train_test_split
train_df, test_df = train_test_split(ratings_df, test_size=0.2, random_state=1234)
```

이 셋을 이용해 간단히 랜덤으로 평점을 예측하는 말도 안 되는 추천을 한 번 해봅시다.

### 랜덤으로 평점 예측 해보기

평점은  0.5 , 1.0 , 1.5 , ..., 5 의 값을 가집니다. 이를 만들 때 `numpy`를 사용하면 됩니다.

``` `python
import numpy as np
ratings_range = np.arange(0.5, 5.5, step=0.5)
```

`np.arange()`는 시작점과 끝점, 그리고 늘어나는 정도를 주면 자동으로 그 사이의 모든 값으로 이루어진 배열을 만들어 줍니다.

이제 이 값들을 랜덤으로 선택해서 실제 rating값과 비교해야겠네요. 랜덤으로 선택된 값으로 이루어진 리스트를 만들어줍니다.

​``` python
import random
pred_random = [random.choice(ratings_range) for _ in range(len(test_df))]
```

그리고 이렇게 만든 리스트를 테스트 셋의 컬럼으로 붙여줍니다,

```python
test_df['pred_ratings_random'] = pred_random
```

이제 `test_df`에는 실제 rating과 랜덤으로 선택된 rating값이 한 행에 같이 존재합니다. 이 값들을 이용해 추천 시스템을 평가할 때 사용할 수 있는 지표 중 **RMSE**를 사용하겠습니다. **RMSE**에 대해서는 이전 글에서 언급했으니 간단히만 설명하면 평균 제곱근 편차, 즉 편차의 평균을 제곱근한 값입니다. **MSE**, 즉 평균 제곱 오차를 구해주는 기능이 `sklearn`에 있기 때문에 사용해서 구해봅시다.

``` python
from sklearn.metrics import mean_squared_error

mse = mean_squared_error(y_true=test_df['rating'].values, y_pred=test_df['pred_ratings_random'].values)
rmse = np.sqrt(mse)
print(mse, rmse)
```

```
3.6989289964299883 1.9232599918965685
```

**RMSE**값이 약 1.9로 상당히 높은 것을 알 수 있습니다. **RMSE**가 1.9라는 의미는 실제 rating은 3이지만 예측값은 1.1 혹은 4.9라는 말입니다. 거의 못 맞춘다고 보면 되겠네요. 이제 랜덤으로 추천하는 경우가 말이 안 된다는 것을 직접 경험해봤으니 그나마 나은 것을 선택해서 연습해봅시다.

###  영화 평균 평점기반 예측하기

`train_set`에 있는 영화 각각에 대한 rating의 평균을 구합니다. 그리고 `test_set`에서 그 영화에 대해서는 구해놓은 평균값을 이용해 예측해보겠습니다. `test_set`에는 있는데 `train_set`에는 없는 영화가 있을 경우에는 위의 랜덤 방식을 사용하겠습니다.

``` python
train_movie_df = train_df.groupby('movieId').mean()
def avg_pred(train_df,idx):
    if idx in train_df.index:
        return train_df.loc[x]['rating']
    else:
        return random.choice(ratings_range)

test_df['pred_rating_movie'] = test_df['movieId'].apply(lambda x: movie_avg_pred(train_movie_df,x))
```

``` python
mse = mean_squared_error(y_true=test_df['rating'].values, y_pred=test_df['pred_rating_movie'].values)
rmse = np.sqrt(mse)
```

```
1.0549461693486206 1.0271057245233426
```

`DataFrame.apply()`는 행, 열, 또는 전체 셀(=원소)에 인자로 주는 연산을 할 수 있습니다. `axis`를 지정해서 행 또는 열을 선택할 수 있습니다.

결과를 보면 **RMSE** 값이 1.0으로 랜덤으로 선택한 것보다 0.9가량 낮습니다. 이 말은 랜덤보다는 영화의 평균 평점으로 예측한 것이 실제 값과 0.9정도 가깝다는 것을 의미합니다. 그럼 이제 사용자가 준 평점을 사용해서 예측해봅시다.

### 사용자 평균 평점기반 예측하기

위에서는 각각 영화에 대한 rating의 평균을 구했는데 이번에는 각 유저가 준 rating들의 평균을 구해서 예측해보겠습니다.

``` python
train_user_df = train_df.groupby('userId').mean()

test_df['pred_rating_user'] = test_df['userId'].apply(lambda x: avg_pred(train_user_df,x))
```

``` python
mse = mean_squared_error(y_true=test_df['rating'].values, y_pred=test_df['pred_rating_user'].values)
rmse = np.sqrt(mse)
```

```
0.8905889036428333 0.9437101798978504
```

이전 결과보다 **RMSE**값이 0.1정도, 즉 10%정도 성능이 향상했다고 평가할 수 있습니다. 만약 유저 1번이 준 평점의 평균이 4라고 생각해봅시다. 이 말은 곧 유저 1번은 어떤 영화를 보든지 간에 고득점 위주로 평점을 남긴다는 것을 의미할 수 있습니다. 그래서 사용자 평균 평점을 기준으로 예측했을 때 영화 평균 평점보다 좀 더 나은 결과를 얻는 것입니다. 이제는 조금 다른 방식으로 평점을 예측해보겠습니다.

### Rule 기반 영화 평점 예측하기

`train_df`를 우리가 원하는 형태로 바꿔보겠습니다. DataFrame을 재구성할 때는 `DataFrame.pivot()`을 사용합니다. 

``` python
train_user_movie_matrix = train_df.pivot(
	index = 'movieId',
    columns = 'userId',
    values = 'rating'
).fillna(0)
```

이번에는 영화 장르별로 평균 평점을 구하고, `test_df`의 영화들에 대해 장르를 구한 후 장르에 대한 평균평점으로 예측하려고 합니다. 그럼 `genre_df`도 만들어 줘야 합니다. 이 때 `train_df`에 있는 genre들만 가지고 만들어야 하고, 만약 `test_df`에 구하지 않은 장르가 나온다면, 랜덤으로 선택해야 합니다.

``` python
genres_df = movies_df['genres'].str.get_dummies(sep='|')
genres_df = genres_df.loc[train_df.movieId.unique()]
```

`train_df`의 영화들이 어떤 장르로 구성되어 있는지 알았으니, 이제 영화의 평점을 구하고, 그 영화가 어떤 장르에 속한지 구한 뒤, 각각 장르에 대해 장르를 포함하는 영화의 평균 평점의 평균을 구하면 됩니다. 말이 너무 어려우니 코드를 보며 따라가 봅시다.

``` python
train_movie_avg_ratings_df train_user_movie_matrix.copy()
train_movie_avg_ratings_df = train_movie_avg_ratings_df.replace(0, np.NaN)
train_movie_avg_ratings_df = train_movie_avg_ratings_df.mean(axis = 1)
```

영화에 대한 평점의 평균을 구했습니다. 이제 장르를 포함하는 영화들을 모아 그 영화 각각의 평균 평점을 모두 더한 뒤 갯수만큼 나눠줘서 평균을 구하겠습니다.

``` python
genres_avg_ratings_df = pd.DataFrame(index=genres_df.columns, columns=['avg_ratings'])
for genre in genres_avg_ratings_df.index:
    genre_avg_rating = 							 train_movie_avg_ratings_df.loc[genres_df[genres_df[genre].isin([1])].index].mean()
    genres_avg_ratings_df.loc[genre]['avg_ratings'] = genre_avg_rating
```

`genre`에 대하여 1인, 즉 그 장르를 포함하는 영화들의 평균을 낸 값이 `genre_avg_rating` 입니다.

``` python
def get_genre_avg_ratings(x):
    genres_list = movies_df.loc[x]['genres'].split('|')
    rating = 0
    for genre in genres_list:
        rating += genres_avg_ratings_df.loc[genre]['avg_ratings']
    
    return rating / len(genres_list)
```

이제 우리가 평점을 예측하려는 영화의 장르를 모두 모아, 그 장르들의 값들을 다 더하고 갯수만큼 나눠주면 최종 결과가 됩니다.

정리해보면, 영화의 평균 평점을 구하고, 그 값들을 이용해 장르의 평균 평점을 구하고, 마지막으로 예측할 때 장르의 평균 평점의 평균을 이용한 것입니다.

결과 :

```
1.1251906030478547 1.0607500191128232
```

영화의 평균 평점을 이용했을 때와 거의 비슷한 성능을 보여주고 있습니다. 저희가 장르의 평균 평점을 구할 때도 영화의 평균 평점을 이용했기 때문에 당연한 결과입니다. 이 때까지의 결과를 살펴보면 영화에 대한 정보보다 사용자 각각에 대한 정보가 추천 시스템의 성능을 좌우하는데 더 큰 영향을 미치는 것을 알 수 있습니다.

간단한 방식들로 데이터셋에 대해 연습해봤는데,  여기서 결과로 나온 값들이 높고 낮음에 따라 성능이 좋고 나쁘고를 따지고자 한 것이 아닙니다. 어떤 데이터를 사용했을 때는 **RMSE**가 어떻게 되었는지를 보면서 추천을 할 때 중요시 여겨야 하는 데이터가 어떤 것인지 생각하면 좋을 것 같습니다.





